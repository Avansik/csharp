namespace _15_02_Generics

{

    class Stack<Type>

    {

        private Type[] myArr;

        public Type[] MyArr

        {

            get { return myArr; }

            set { myArr = value; }

        }

        public void Pop()

        {

            Array.Resize(ref myArr, myArr.Length - 1);

        }

        public void Push(Type value)

        {

            Array.Resize(ref myArr, myArr.Length);

        }


    }



    internal class Program

    {

        public static T Max<T>(T a, T b, T c) where T : IComparable<T>

        {

            T max = a;

            if (b.CompareTo(max) > 0)

                max = b;

            if (c.CompareTo(max) > 0)

                max = c;

            return max;

        }

        public static T Min<T>(T a, T b, T c) where T : IComparable<T>

        {

            T min = a;

            if (b.CompareTo(min) < 0)

                min = b;

            if (c.CompareTo(min) < 0)

                min = c;

            return min;

        }

        public static T Summ<T>(T[] array) where T : IComparable<T>

        {

            dynamic sum = 0;

            foreach (var t in array)

            {

                sum += t;

            }

            return sum;

        }


        static void Main(string[] args)

        {

        }

    }

}





































namespace _15_02_Generics
{
    class Stack<Type>
    {
        private Type[] myArr;
        public int Count => myArr.Length;
        public Type[] MyArr

        {

            get { return myArr; }

            set { myArr = value; }

        }

        public void Pop()

        {

            Array.Resize(ref myArr, myArr.Length - 1);

        }

        public void Push(Type value)

        {

            Array.Resize(ref myArr, myArr.Length);

        }
        public Type Peek()
        {
            return myArr[myArr.Length - 1];
        }

    }



    internal class Program

    {

        public static T Max<T>(T a, T b, T c) where T : IComparable<T>

        {

            T max = a;

            if (b.CompareTo(max) > 0)

                max = b;

            if (c.CompareTo(max) > 0)

                max = c;

            return max;

        }

        public static T Min<T>(T a, T b, T c) where T : IComparable<T>

        {

            T min = a;

            if (b.CompareTo(min) < 0)

                min = b;

            if (c.CompareTo(min) < 0)

                min = c;

            return min;

        }

        public static T Summ<T>(T[] array) where T : IComparable<T>

        {

            dynamic sum = 0;

            foreach (var t in array)

            {

                sum += t;

            }

            return sum;

        }
        class Queue<Type>
        {
            private Type[] myArr;
            public int Count => myArr.Length;
            public void Enqueue(Type value)
            {
                Array.Resize(ref myArr, myArr.Length + 1);
                myArr[myArr.Length - 1] = value;
            }
            public Type Dequeue()
            {
                Type value = myArr[0];
                for (int i = 1; i < myArr.Length; i++)
                    myArr[i - 1] = myArr[i];
                Array.Resize(ref myArr, myArr.Length - 1);
                return value;
            }
            public Type Peek()
            {
                return myArr[0];
            }
        }
        static void Main(string[] args)

        {
            /*Завдання 1 Створіть generic-версію методу обчислення максимуму з трьох чисел.
             * Завдання 2 Створіть generic-версію методу обчислення мінімуму з трьох чисел.
             * Завдання 3 Створіть generic-версію методу пошуку суми елементів у масиві.
             * Завдання 4 Створіть generic-клас «Стек». Реалізуйте стандартні методи і властивості для роботи стеку: ■ pop; ■ push; ■ peek; ■ count.
             Завдання 5 Створіть generic-клас «Черга». Реалізуйте стандартні методи і властивості для роботи черги: ■ enqueue; ■ dequeue; ■ peek; ■ count.*/
            int a = 5, b = 10, c = 15;
            Console.WriteLine("max : " + Max(a, b, c));
            Console.WriteLine("min : " + Min(a, b, c));
            int[] arr = { 1, 2, 3, 4, 5 };
            Console.WriteLine("sum : " + Summ(arr));
            Stack<int> stack = new Stack<int>();
            stack.MyArr = new int[] { 1, 2, 3, 4, 5 };
            Console.WriteLine("stack count : " + stack.Count);
            Console.WriteLine("stack peek : " + stack.Peek());
            stack.Pop();
            Console.WriteLine("stack count : " + stack.Count);
            stack.Push(6);
            Console.WriteLine("stack count : " + stack.Count);
            Queue<int> queue = new Queue<int>();
            queue.Enqueue(1);
            queue.Enqueue(2);
            queue.Enqueue(3);
            Console.WriteLine("queue count : " + queue.Count);
            Console.WriteLine("queue peek : " + queue.Peek());
            Console.WriteLine("dequeue : " + queue.Dequeue());
        }

    }

}

